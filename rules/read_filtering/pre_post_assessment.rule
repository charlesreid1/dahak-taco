import os, re
from os.path import join, dirname


data_dir = config['data_dir']

try:
    readfilt = config['read_filtering']
except KeyError:
    readfilt = {}

try:
    biocontainers = config['biocontainers']
except KeyError:
    biocontainers = {}

PWD = os.getcwd()

pre_trimming_input  = join(data_dir, readfilt['read_patterns']['pre_trimming_pattern'])
target_suffix = readfilt['quality_assessment']['fastqc_suffix']
target_ext = "%s.zip"%(target_suffix)
pre_trimming_output = re.sub('\.fq\.gz',target_ext,pre_trimming_input)


# Get the quay URL
# 
# To allow the user to use local Dockerfiles,
# in case something in bioconda is borked,
# we require the user to specify the name 
# of the docker image to run, and set 
# use_local to true
# 
# The 'use_local' key should indicate
# whether to use a local Docker image.
# If it is true, the 'local' key
# should indicate the local image to use.
# Those are checked in utilities.py
app = 'fastqc'
fastqc_image = container_image_name(biocontainers, app)

rule pre_trimming_quality_assessment:
    """
    Perform a pre-trimming quality check 
    of the reads from the sequencer.
    """
    input:
        pre_trimming_input
    output: 
        pre_trimming_output
    message: 
        '''--- Pre-trim quality check of trimmed data with fastqc.'''
    singularity: 
        fastqc_image
    threads: 2
    run:
        # get output file name with wildcards replaced
        pre_trimming_output_wc = pre_trimming_output.format(**wildcards)

        # get input file name with wildcards replaced
        pre_trimming_input_wc = pre_trimming_input.format(**wildcards)

        # get directory for final output
        output_dir = dirname(pre_trimming_output_wc)

        shell('''
            set -x
            docker run \
                -u "$(id -u):$(id -g)" \
                -v {PWD}/{data_dir}:/{data_dir} \
                -it \
                {fastqc_image} \
                fastqc \
                -t {threads} \
                /{pre_trimming_input_wc} \
                -o /{data_dir}
        ''')


post_trimming_input  = join(data_dir, readfilt['read_patterns']['post_trimming_pattern'])
target_suffix = readfilt['quality_assessment']['fastqc_suffix']
target_ext = "%s.zip"%(target_suffix)
post_trimming_output = re.sub('\.fq\.gz',target_ext,post_trimming_input)


rule post_trimming_quality_assessment:
    """
    Perform a post-trimming quality check 
    of the reads from the sequencer.
    """
    input:
        post_trimming_input
    output:
        post_trimming_output
    message: 
        '''--- Post-trim quality check of trimmed data with fastqc.'''
    singularity: 
        fastqc_image
    threads: 2 
    run:
        # get output file name with wildcards replaced
        pre_trimming_output_wc = pre_trimming_output.format(**wildcards)

        # get input file name with wildcards replaced
        pre_trimming_input_wc = pre_trimming_input.format(**wildcards)

        # get directory for final output
        output_dir = dirname(pre_trimming_output_wc)

        shell('''
            set -x
            docker run \
                -u "$(id -u):$(id -g)" \
                -v {PWD}/{data_dir}:/{data_dir} \
                -it \
                {fastqc_image} \
                fastqc \
                -t {threads} \
                /{pre_trimming_input_wc} \
                -o /{data_dir}
        ''')

